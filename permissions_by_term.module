<?php
/**
 * @file
 * Allows access to terms in a vocabulary to be limited by user or role.
 */

use \Drupal\Core\Form\FormState;
use \Drupal\permissions_by_term\AccessStorageService;
use Drupal\Core\Url;


/**
 * Implements hook_help().
 */
function permissions_by_term_help($path, $arg) {
  switch ($path) {
    case 'admin/help#permissions_by_term':
      $output = '<p>' . t('This module allows taxonomy administrators the
        ability to restrict setting individual terms on nodes by user
        or role. If a user is unable to set any terms for a required
        vocabulary, they are blocked from adding or editing content with
        that vocabulary.') . '</p>';
      $output .= '<p>' . t('To add permissions for a term, go to
        Administer >> Content Management >> Taxonomy, and add or
        edit a term. If the permissions are left blank, the term is
        available to all users.') . '</p>';
      return $output;
  }
}

/**
 * Validation handler for permissions_by_term_form_alter().
 */
function permissions_by_term_validate($form, FormState $oFormState) {
    $oDbConnection = \Drupal::database();
    $accessService = new AccessStorageService($oDbConnection,
      $oFormState);
    $accessService->checkIfUsersExists();
}

/**
 * Submit handler for permissions_by_term_form_alter().
 */
function permissions_by_term_submit($form, FormState $oFormState) {
  $oDbConnection = \Drupal::database();
  $accessService = new AccessStorageService($oDbConnection,
    $oFormState);
  $accessService->saveTermPermissions();
}


/**
 * Implements hook_views_post_execute().
 *
 * Hides nodes in every view on the site.
 */
function permissions_by_term_views_post_execute(&$view) {
  $user = \Drupal::currentUser();

  $view_contains_nodes = FALSE;

  foreach ($view->result as $view_result) {
    if (array_key_exists('nid', $view_result) === TRUE) {
      $view_contains_nodes = TRUE;
    }
  }

  if ($view_contains_nodes === TRUE) {
    $arr__nodes_to_hide_in_view = array();
    foreach ($view->result as $v) {

      $node = \Drupal::entityManager()->getStorage('node')->load($v->nid);

      $secured_areas = field_get_items('node', $node, 'field_secured_areas');

      if (!empty($secured_areas)) {
        foreach ($secured_areas as $term) {
          if (isset($term['tid']) &&
            permissions_by_term_allowed($term['tid'], $user) === TRUE) {
            $user_is_allowed_to_view = TRUE;
          }

          if (!isset($user_is_allowed_to_view)) {
            $user_is_allowed_to_view = FALSE;
            $arr__nodes_to_hide_in_view[] = $node->nid;
          }

        }
      }

    }

    $arr__new_results = array();

    // Hide the nodes.
    foreach ($view->result as $v) {
      if (!in_array($v->nid, $arr__nodes_to_hide_in_view)) {
        $arr__new_results[] = $v;
      }
    }

    $view->result = $arr__new_results;
  }

}

/**
 * Implements hook_node_access().
 *
 * Forwards user by drupal_access_denied(); to an access denied page, if a
 * single restricted node is called.
 */
function permissions_by_term_node_access(\Drupal\node\NodeInterface $node, $op,
                                         \Drupal\Core\Session\AccountInterface $account) {

  if (isset($node->nid) && $op == 'view') {

    // @TODO: working on access check by node id. Have to create field with name "field_secured_areas".
    $oField = $node->get('field_secured_areas');

    $aReferencedTaxonomyTerms = $oField->getValue();

    if (!empty($aReferencedTaxonomyTerms)) {
      $user = \Drupal::currentUser();
      foreach ($aReferencedTaxonomyTerms as $aReferencedTerm) {

        if (isset($aReferencedTerm['target_id']) &&
          permissions_by_term_allowed($aReferencedTerm['target_id'], $user) === TRUE) {
          $user_is_allowed_to_view = TRUE;
        }
        if (!isset($user_is_allowed_to_view)) {
          $user_is_allowed_to_view = FALSE;
        }
      }
    }

    if (isset($user_is_allowed_to_view) && $user_is_allowed_to_view === FALSE) {
      return \Drupal\Core\Access\AccessResult::forbidden();
    } else {
      return \Drupal\Core\Access\AccessResult::allowed();
    }
  }

}

/**
 * Implements permissions_by_term_allowed().
 */
function permissions_by_term_allowed($tid, $user) {

  if ($user->id() == 1) {
    return TRUE;
  }

  // Are permissions enabled on this term? Check for role and user.
  if (!(db_query("SELECT COUNT(1) FROM {permissions_by_term_user} WHERE tid = :tid",
    array(':tid' => $tid))->fetchField() ||
    db_query("SELECT COUNT(1) FROM {permissions_by_term_role} WHERE tid = :tid",
    array(':tid' => $tid))->fetchField())) {
    return TRUE;
  }

  /**
   * At this point permissions are enabled, check to see if this user or one
   * of their roles is allowed.
   */
  $aUserRoles = $user->getRoles();

  foreach ($aUserRoles as $sUserRole) {
    if (db_query("SELECT uid FROM {permissions_by_term_user} WHERE tid = :tid AND uid = :uid",
        array(':tid' => $tid, ':uid' => $user->id()))->fetchField() ||
      db_query("SELECT rid FROM {permissions_by_term_role} WHERE tid = :tid AND rid IN (:user_roles)",
        array(':tid' => $tid, ':user_roles' => $sUserRole))->fetchField()) {
      return TRUE;
    }
  }

  return FALSE;

}

/**
 * Implements hook_form_alter().
 */
function permissions_by_term_form_taxonomy_term_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $oFormState, $form_id) {

  if (\Drupal::currentUser()->hasPermission('show term permission form on term page')) {

    $iTermId = getFormTermId();
    $oDbConnection = \Drupal::database();
    $oAccessStorageService = new AccessStorageService($oDbConnection,
      $oFormState, $iTermId);

    $form['access'] = array(
      '#type' => 'fieldset',
      '#title' => t('Permissions'),
      '#description' => t('To limit selection of this term by user or roles,
      add users or roles to the following lists. Leave empty to allow
      selection by all users.'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#attributes' => array('id' => 'fieldset_term_access'),
      '#weight' => -5,
      '#tree' => TRUE,
    );

    $aAllowedUsers = $oAccessStorageService->getAllowedUserIds();
    if (!empty($aAllowedUsers)) {
      $aAllowedUsers = user_load_multiple($aAllowedUsers);
      $sUserFormValue = $oAccessStorageService->getUserFormValue($aAllowedUsers);
    } else {
      $sUserFormValue = NULL;
    }

    // @TODO: Working on autocomplete functionality. Currently comes "The user 1 does not exist." after submited form.

    $debug = true;

    // Note that the autocomplete widget will only enable for users with the
    // 'access profiles' permission. Other users will have to specify the name
    // manually.
    $form['access']['user'] = array(
      '#type' => 'entity_autocomplete',
      '#target_type' => 'user',
      '#title' => t('Allowed users'),
      '#description' => t('Enter a comma-seperated list of user names to give') . ' ' .
        t('them permission to use this term.'),
      '#value' => $sUserFormValue,
      '#size' => 60,
      '#autocomplete_route_name' => 'permissions_by_term.autocomplete_multiple',
      '#weight' => -10,
    );

    $aAllowedRoles = $oAccessStorageService->getExistingRoleTermPermissionsByTid();

    // firstly fetch all translated allowed role names.
    $aTranslatedAllowedRoleNames = array();
    foreach($aAllowedRoles as $role){
      $aTranslatedAllowedRoleNames[] = t($role);
    }

    // get all roles for the complete form and translate them.
    $aTranslatedUserRoles = array();
    $array_key_counter = 1;
    foreach(user_roles() as $user_role_id=>$user_role_name){
      $aTranslatedUserRoles[$user_role_id] = t($user_role_name->label());
      $array_key_counter++;
    }

    // generate the default values for the form.
    $aSetRoles = array();
    if(!empty($aTranslatedAllowedRoleNames)){
      foreach($aTranslatedAllowedRoleNames as $role_name){
          $aSetRoles[] = $role_name->__toString();

      }
    }

    // Now, lets do the Roles table.
    $form['access']['role'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Allowed roles'),
      '#description' => t('Select a role to allow all members of that role access to this term.'),
      '#default_value' => $aSetRoles,
      '#options' => $aTranslatedUserRoles,
      //'#options' => user_roles(),
      '#multiple' => FALSE,
      '#weight' => 5,
    );

    $form['#validate'][] = 'permissions_by_term_validate';
    $form['actions']['submit']['#submit'][] = 'permissions_by_term_submit';
  }

}

/**
 * Gets the term id from the current form.
 *
 * @return int
 */
function getFormTermId() {
  $aUrl = explode('/', $_SERVER['REQUEST_URI']);
  return intval($aUrl['3']);
}
