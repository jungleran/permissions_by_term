<?php
/**
 * @file
 * Allows access to terms in a vocabulary to be limited by user or role.
 */

use \Drupal\Core\Form\FormState;
use \Drupal\permissions_by_term\AccessStorageService;
use Drupal\Core\Url;


/**
 * Implements hook_help().
 */
function permissions_by_term_help($path, $arg) {
  switch ($path) {
    case 'admin/help#permissions_by_term':
      $output = '<p>' . t('This module allows taxonomy administrators the
        ability to restrict setting individual terms on nodes by user
        or role. If a user is unable to set any terms for a required
        vocabulary, they are blocked from adding or editing content with
        that vocabulary.') . '</p>';
      $output .= '<p>' . t('To add permissions for a term, go to
        Administer >> Content Management >> Taxonomy, and add or
        edit a term. If the permissions are left blank, the term is
        available to all users.') . '</p>';
      return $output;
  }
}

/**
 * Implements hook_menu().
 */
function permissions_by_term_menu() {
  $items = array();
  $items['permissions-by-term/autocomplete'] = array(
    'title' => '',
    'page callback' => 'permissions_by_term_autocomplete_multiple',
    'access arguments' => array('access user profiles'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_form_alter().
 */
//function permissions_by_term_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $oFormState, $form_id) {
  // This is the node add / edit form. If a different selector is used from
  // another contributed module, we do nothing so as to not break the form.
  // @FIXME
// // @FIXME
// // This looks like another module's variable. You'll need to rewrite this call
// // to ensure that it uses the correct configuration object.
// if ((isset($form['type']) && isset($form['#node']) && (!variable_get('taxonomy_override_selector', FALSE)) && $form['type']['#value'] . '_node_form' == $form_id) ||
//        (isset($form['#entity_type']) && isset($form['#bundle']))) {
//     // Field types we are looking for.
//     $types = array('taxonomy_term_reference');
//     foreach (element_children($form) as $field_name) {
//       if (!$field_info = field_info_field($field_name)) {
//         continue;
//       }
//       if (!in_array('#language', $form[$field_name])) {
//         continue;
//       }
//       $options = &$form[$field_name][$form[$field_name]['#language']]['#options'];
//       if (!in_array($field_info['type'], $types) || !isset($options)) {
//         continue;
//       }
//
//       foreach ($options as $tid => $name) {
//         if ($tid == "_none") {
//           continue;
//         }
//
//         // Now we have the term ID, check to see if the current user has
//         // access to the term.
//         $user = \Drupal::currentUser();
//         if (!permissions_by_term_allowed($tid, $user)) {
//           unset($options[$tid]);
//         }
//       }
//     }
//   }

//}

/**
 * Validation handler for permissions_by_term_form_alter().
 */
function permissions_by_term_validate($form, FormState $oFormState) {
    $oDbConnection = \Drupal::database();
    $accessService = new AccessStorageService($oDbConnection,
      $oFormState);
    $accessService->checkIfUsersExists();
}

/**
 * Submit handler for permissions_by_term_form_alter().
 */
function permissions_by_term_submit($form, FormState $oFormState) {
  $oDbConnection = \Drupal::database();
  $accessService = new AccessStorageService($oDbConnection,
    $oFormState);
  $accessService->saveTermPermissions();
}


/**
 * Implements hook_views_post_execute().
 *
 * Hides nodes in every view on the site.
 */
function permissions_by_term_views_post_execute(&$view) {
  $user = \Drupal::currentUser();

  $view_contains_nodes = FALSE;

  foreach ($view->result as $view_result) {
    if (array_key_exists('nid', $view_result) === TRUE) {
      $view_contains_nodes = TRUE;
    }
  }

  if ($view_contains_nodes === TRUE) {
    $arr__nodes_to_hide_in_view = array();
    foreach ($view->result as $v) {

      $node = \Drupal::entityManager()->getStorage('node')->load($v->nid);

      $secured_areas = field_get_items('node', $node, 'field_secured_areas');

      if (!empty($secured_areas)) {
        foreach ($secured_areas as $term) {
          if (isset($term['tid']) &&
            permissions_by_term_allowed($term['tid'], $user) === TRUE) {
            $user_is_allowed_to_view = TRUE;
          }

          if (!isset($user_is_allowed_to_view)) {
            $user_is_allowed_to_view = FALSE;
            $arr__nodes_to_hide_in_view[] = $node->nid;
          }

        }
      }

    }

    $arr__new_results = array();

    // Hide the nodes.
    foreach ($view->result as $v) {
      if (!in_array($v->nid, $arr__nodes_to_hide_in_view)) {
        $arr__new_results[] = $v;
      }
    }

    $view->result = $arr__new_results;
  }

}

/**
 * Implements hook_node_access().
 *
 * Forwards user by drupal_access_denied(); to an access denied page, if a
 * single restricted node is called.
 */
function permissions_by_term_node_access($node, $op, $account) {

  if (isset($node->nid) && $op == 'view') {
    $node = \Drupal::entityManager()->getStorage('node')->load($node->nid);
    $secured_areas = field_get_items('node', $node, 'field_secured_areas');
    if (!empty($secured_areas)) {
      $user = \Drupal::currentUser();
      foreach ($secured_areas as $term) {

        $term_secured_areas = $term;

        if (isset($term_secured_areas['tid']) &&
          permissions_by_term_allowed($term_secured_areas['tid'], $user) === TRUE) {
          $user_is_allowed_to_view = TRUE;
        }
        if (!isset($user_is_allowed_to_view)) {
          $user_is_allowed_to_view = FALSE;
        }
      }
    }
    if (isset($user_is_allowed_to_view) && $user_is_allowed_to_view === FALSE) {
      return NODE_ACCESS_DENY;
    }
  }

}

/**
 * Implements permissions_by_term_allowed().
 */
function permissions_by_term_allowed($tid, $user) {

  if ($user->uid == 1) {
    return TRUE;
  }

  // Are permissions enabled on this term?
  if (!(db_query("SELECT COUNT(1) FROM {permissions_by_term_user} WHERE tid = :tid",
    array(':tid' => $tid))->fetchField() ||
    db_query("SELECT COUNT(1) FROM {permissions_by_term_role} WHERE tid = :tid",
    array(':tid' => $tid))->fetchField())) {
    return TRUE;
  }

  /* Permissions are enabled, check to see if this user or one of their roles
  is allowed.
   */
  $user_roles = array_keys($user->roles);

  $i = 0;

  while (isset($user_roles[$i])) {

    if (db_query("SELECT uid FROM {permissions_by_term_user} WHERE tid = :tid AND uid = :uid",
        array(':tid' => $tid, ':uid' => $user->uid))->fetchField() ||
        db_query("SELECT rid FROM {permissions_by_term_role} WHERE tid = :tid AND rid IN (:user_roles)",
        array(':tid' => $tid, ':user_roles' => $user_roles[$i]))->fetchField()) {
      return TRUE;
    }

    $i++;

  }

  return FALSE;

}

/**
 * Page callback: Returns Json array for autocomplete fields.
 *
 * Supports multiple entries separated by a comma.
 *
 * @param string $string
 *   A comma-separated list of users.
 */
function permissions_by_term_autocomplete_multiple($string) {
  // The user enters a comma-separated list of users.
  // We only autocomplete the last user.
  $array = drupal_explode_tags($string);

  // Fetch last user.
  $last_string = trim(array_pop($array));

  $matches = array();
  $result = db_select('users')->fields('users', array('name'))->condition('name',
            db_like($last_string) . '%', 'LIKE')->range(0, 10)->execute();

  $prefix = count($array) ? implode(', ', $array) . ', ' : '';

  foreach ($result as $user) {
    $matches[$prefix . $user->name] = \Drupal\Component\Utility\SafeMarkup::checkPlain($user->name);
  }
  drupal_json_output($matches);
}

/**
 * Implements hook_form_alter().
 */
function permissions_by_term_form_taxonomy_term_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $oFormState, $form_id) {

  if (\Drupal::currentUser()->hasPermission('show term permission form on term page')) {

    $iTermId = getFormTermId();
    $oDbConnection = \Drupal::database();
    $oAccessStorageService = new AccessStorageService($oDbConnection,
      $oFormState, $iTermId);

    $form['access'] = array(
      '#type' => 'fieldset',
      '#title' => t('Permissions'),
      '#description' => t('To limit selection of this term by user or roles,
      add users or roles to the following lists. Leave empty to allow
      selection by all users.'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#attributes' => array('id' => 'fieldset_term_access'),
      '#weight' => -5,
      '#tree' => TRUE,
    );

    $sAllowedUsers = '';

    // Pull in any stored users in the database.
    if (!empty($form['tid']['#value'])) {
      $aAllowedUsers = $oAccessStorageService->getAllowedUserNames();
      $sAllowedUsers = implode(', ', $aAllowedUsers);
    }

    // Note that the autocomplete widget will only enable for users with the
    // 'access profiles' permission. Other users will have to specify the name
    // manually.
    $form['access']['user'] = array(
      '#type' => 'textfield',
      '#title' => t('Allowed users'),
      '#description' => t('Enter a comma-seperated list of user names to give') .
        t('them permission to use this term.'),
      '#default_value' => $sAllowedUsers,
      '#size' => 60,
      '#autocomplete_path' => 'permissions-by-term/autocomplete',
      '#weight' => -10,
    );

    $aAllowedRoles = $oAccessStorageService->getExistingRoleTermPermissionsByTid();

    // firstly fetch all translated allowed role names.
    $aTranslatedAllowedRoleNames = array();
    foreach($aAllowedRoles as $role){
      $aTranslatedAllowedRoleNames[] = t($role);
    }

    // get all roles for the complete form and translate them.
    $aTranslatedUserRoles = array();
    $array_key_counter = 1;
    foreach(user_roles() as $user_role_id=>$user_role_name){
      $aTranslatedUserRoles[$user_role_id] = t($user_role_name->label());
      $array_key_counter++;
    }

    // generate the default values for the form.
    $aSetRoles = array();
    if(!empty($aTranslatedAllowedRoleNames)){
      foreach($aTranslatedAllowedRoleNames as $role_name){
          $aSetRoles[] = $role_name->__toString();

      }
    }

    // Now, lets do the Roles table.
    $form['access']['role'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Allowed roles'),
      '#description' => t('Select a role to allow all members of that role access to this term.'),
      '#default_value' => $aSetRoles,
      '#options' => $aTranslatedUserRoles,
      //'#options' => user_roles(),
      '#multiple' => FALSE,
      '#weight' => 5,
    );

    $form['#validate'][] = 'permissions_by_term_validate';
    $form['actions']['submit']['#submit'][] = 'permissions_by_term_submit';
  }

}

/**
 * Gets the term id from the current form.
 *
 * @return int
 */
function getFormTermId() {
  $aUrl = explode('/', $_SERVER['REQUEST_URI']);
  return intval($aUrl['3']);
}
