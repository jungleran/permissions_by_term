<?php
/**
 * @file
 * Allows access to terms in a vocabulary to be limited by user or role.
 */

use \Drupal\Core\Form\FormState;
use \Drupal\permissions_by_term\AccessStorageService;
use \Drupal\permissions_by_term\Controller\PermissionsByTermController;

/**
 * Implements hook_help().
 */
function permissions_by_term_help($path, $arg) {
  switch ($path) {
    case 'admin/help#permissions_by_term':
      $output = '<p>' . t('This module allows taxonomy administrators the
        ability to restrict setting individual terms on nodes by user
        or role. If a user is unable to set any terms for a required
        vocabulary, they are blocked from adding or editing content with
        that vocabulary.') . '</p>';
      $output .= '<p>' . t('To add permissions for a term, go to
        Administer >> Content Management >> Taxonomy, and add or
        edit a term. If the permissions are left blank, the term is
        available to all users.') . '</p>';
      return $output;
  }
}

/**
 * Validation handler for permissions_by_term_form_alter().
 */
function permissions_by_term_validate($form, FormState $oFormState) {
  // @TODO: as in issue #2756809 - check if all term relation fields contain only allowed terms.


  $oDbConnection = \Drupal::database();
  $accessService = new AccessStorageService($oDbConnection,
    $oFormState);
  $accessService->checkIfUsersExists();
}

/**
 * Implements hook_entity_update().
 */
function permissions_by_term_entity_update(Drupal\Core\Entity\EntityInterface $entity) {
  $def = $entity->getFieldDefinition($entity->get('field_tags'));
  $field_definitions = $entity->getFieldDefinitions();
  foreach ($field_definitions as $field) {
    $type = $field->getType();
    $target_type = $field_definitions['field_tags']->getItemDefinition()->getSettings()['target_type'];
    if ($type == 'entity_reference' && $target_type == 'taxonomy_term') {
      $debug = true;
    }
  }

}

/**
 * Submit handler for permissions_by_term_form_alter().
 */
function permissions_by_term_submit($form, FormState $oFormState) {
  $oDbConnection = \Drupal::database();
  $iTermId = $oFormState->getFormObject()->getEntity()->id();
  $accessService = new AccessStorageService($oDbConnection, $oFormState, $iTermId);
  $accessService->saveTermPermissions();
}

/**
 * Implements hook_views_post_execute().
 *
 * Hides nodes in every view on the site.
 */
function permissions_by_term_views_post_execute($view) {

  $oPermissionsByTermController = new PermissionsByTermController();
  return $oPermissionsByTermController->handleViews($view);

}

/**
 * Implements hook_node_access().
 *
 * Forwards user by drupal_access_denied(); to an access denied page, if a
 * single restricted node is called.
 *
 * This hook is not fired if admin is logged in. Users with the
 * "bypass node access" permission may always view and edit content
 * through the administrative interface.
 */
function permissions_by_term_node_access(\Drupal\node\NodeInterface $node, $op,
                                         \Drupal\Core\Session\AccountInterface $account) {

  if (method_exists($node, 'id') && $op == 'view') {
    $oPermissionsByTermController = new PermissionsByTermController($node->id());
    return $oPermissionsByTermController->handleNode();
  }

}

/**
 * Implements hook_form_alter().
 */
function permissions_by_term_form_taxonomy_term_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $oFormState, $form_id) {

  if (\Drupal::currentUser()->hasPermission('show term permission form on term page')) {

    $iTermId = $oFormState->getFormObject()->getEntity()->id();
    $oDbConnection = \Drupal::database();
    $oAccessStorageService = new AccessStorageService($oDbConnection, $oFormState, $iTermId);

    $form['access'] = array(
      '#type' => 'fieldset',
      '#title' => t('Permissions'),
      '#description' => t('To limit access to this term by user or roles,
      add users or roles to the following lists. Leave empty to allow
      node access by single node view, node listing in views and taxonomy
      term selection by all users.'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#attributes' => array('id' => 'fieldset_term_access'),
      '#weight' => -5,
      '#tree' => TRUE,
    );

    $aAllowedUsers = $oAccessStorageService->getAllowedUserIds();
    if (!empty($aAllowedUsers)) {
      $aAllowedUsers = user_load_multiple($aAllowedUsers);
      $sUserFormValue = $oAccessStorageService->getUserFormValue($aAllowedUsers);
    }
    else {
      $sUserFormValue = NULL;
    }

    // Note that the autocomplete widget will only enable for users with the
    // 'access profiles' permission. Other users will have to specify the name
    // manually.
    $form['access']['user'] = array(
      '#type' => 'entity_autocomplete',
      '#target_type' => 'user',
      '#title' => t('Allowed users'),
      '#description' => t('Enter a comma-seperated list of user names to give') . ' ' .
        t('them permission to use this term and access related nodes in single node view
        and views listings.'),
      '#value' => $sUserFormValue,
      '#size' => 60,
      '#autocomplete_route_name' => 'permissions_by_term.autocomplete_multiple',
      '#weight' => -10,
    );

    $aAllowedRoles = $oAccessStorageService->getExistingRoleTermPermissionsByTid();

    // firstly fetch all translated allowed role names.
    $aTranslatedAllowedRoleNames = array();
    foreach($aAllowedRoles as $role){
      $aTranslatedAllowedRoleNames[] = t($role);
    }

    // get all roles for the complete form and translate them.
    $aTranslatedUserRoles = array();
    $array_key_counter = 1;
    foreach(user_roles() as $user_role_id=>$user_role_name){
      $aTranslatedUserRoles[$user_role_id] = t($user_role_name->label());
      $array_key_counter++;
    }

    // generate the default values for the form.
    $aSetRoles = array();
    if(!empty($aTranslatedAllowedRoleNames)){
      foreach($aTranslatedAllowedRoleNames as $role_name){
          $aSetRoles[] = $role_name->__toString();

      }
    }

    // Now, lets do the Roles table.
    $form['access']['role'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Allowed roles'),
      '#description' => t('Select a role to allow all members of this role to
        use this term and access related nodes in single node view and views
        listings.'),
      '#default_value' => $aSetRoles,
      '#options' => $aTranslatedUserRoles,
      //'#options' => user_roles(),
      '#multiple' => FALSE,
      '#weight' => 5,
    );

    $form['#validate'][] = 'permissions_by_term_validate';
    $form['actions']['submit']['#submit'][] = 'permissions_by_term_submit';
  }

}

function permissions_by_term_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $oFormState, $form_id) {
  $form['#validate'][] = 'permissions_by_term_validate';
}
